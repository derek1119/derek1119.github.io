---
layout : single
title : MultiThreading
---
# MultiThreading 

- Queues
   앱이 먹통이 되면 앱스토어에서 승인을 내주지 않을 것이다. 이때 사용하는 것이 멀티쓰레딩이다. 멀테 쓰레딩이란, 일을 처리하는 별도의 쓰레드를 갖추는 것이다. 동시에 일을 처리하는 것처럼 보일 것이다. 하지만 싱글 코어 프로레서 상에서 동작을 할 것이다. 시간 분할로 작동하게 되는 것이다. 하나가 작동하고 다른 하나도 작동하지만 왔다갔다하는 방식이다. 각각 조금씩 동작하도록 해주는 것이고 그러다가 어느 하나가 다른 것보다 중요하다면 그게 더 많이 처리되고 다른 것은 그만큼 처리가 많이 되지 않을 것이다. 

  iOS에서 멀티 쓰레딩은 queue(큐, 줄)와 같다. queue라는 것은 영국에서 영화를 보러가면 get in the queue라고 한다. 즉 줄을 서라고 하는 것이다. queue는 뭔가를 처리하기 위해 줄을 선 것들을 말한다. 이 큐에는 iOS 함수를 포함하고 있다. 대부분 여기에 들어간 함수는 개발자가 넣은 클로져로 되어 있다. 이 queue에 넣어 준 코드 블럭을 의미한다. 그러면 시스템은 그냥 이 queue를 실행하게 되고 큐에 있는 다음 것을 꺼내서 처리를 시작하는 것이다. 별도의 쓰레드에서 말이다. 시스템은 각각의 큐에서 꺼내서 각각의 스레드에서 작동시킨다. 

  큐는 직렬로 작동할 수 있는데 큐에서 맨 위에 있던 함수가 꺼내져서 처리를 끝내면 다음 queue를 꺼내지는 방식이다. 
  또는 병렬로 작동하기도 한다. 큐 맨 위에 있던 것이 꺼내져서 쓰레드에서 처리되기 시작하는데 놀고 있는 쓰레드가 더 있다면 큐에서 다음 것을 꺼내서 다른 쓰레드에서 처리하기 시작하는 것이다. 

- Main Queue
  가장 중요한 건 직렬 큐인 Main Queue이다. 메인 큐는 모든 UI가 작동해야 할 곳에서 사용된다. UIKit 프레임워크를 사용해서 무엇을 하더라도 메인 큐 상에서 그것들을 불러야만 한다. 다시 말해, 메인 큐가 아닌 다른 큐에 넣은 클로져에서 그것들을 불러선 안된다는 것이다. 반드시 메인 큐에서 처리해야 한다. 
  이와 반대로 시간이나 리소스를 잡아먹는 UI 외의 모든 처리는 메인 큐 밖에서 처리해야 한다. 메인 큐를 방해하지 않기 위해서다. 이게 유일한 이유는 아니지만 주된 이유이다. 메인 큐에서는 동작하는 것들을 직렬로 처리하기 때문이다. 그 이유는, UI가 순서대로 잘 표현되도록 하기 위해서다. UI를 다른 큐에서 처리되도록 두면 모두 다른 속도로 그려지거나 겹치게 될 것이다. 화면에서 벌어지는 일들이 예측할 수 없게 된다. 
  메인 큐가 클로져나 함수를 꺼내 작업을 처리하는 유일할 때는 메인 큐가 '한가할 때'뿐이다. 다시 말해, 다른 뭔가를 내보내서 처리를 하고 있지 않을 때이다. 시스템은 뒷편에서 늘 메인 큐를 사용하고 있다. 

- Other Queues

- 다른 queue에서 함수를 실행하는 법, 큐에 뭔가를 어떻게 집어 넣을 것인가?

  ```swift
  let queue: dispatch_queue_t = <get the queue you want, more on this in a moment>
  dispatch_async(queue){/*do what you want to do here*/}
  ```

  Dispatch_async는 두 개의 인자를 받아 하나는 넣으려는 큐이고 두 번째는 queue를 넣을 함수이다. 보통 클로져를 사용하고 이 클로저의 좋은 점은 인자를 받지도, 반환하지도 않는 다는 것이다. 그래서 코드로 적어 넣기 쉽다. 하지만 이 클로져에서 UI를 처리할 거라면 메인 큐 외에 다른 큐에 넣지 않는 것이 좋을 것이다. 그렇다면 여기에 넣을 queue인자를 어떻게 가져올까? 

  메인 큐는 DispatchQueue.main.async{} 함수를 호출하면 된다. 반면에 시간을 오래 잡아먹는 것들은 전부 메인 큐 바깥에서 처리되어야 한다. Dispatch_async 메소드로 그 큐를 파견하면 된다. Dispatch_async 함수는 언제나 반환을 즉시 한다. 이 함수가 하는 일은 큐에 뭔가를 집어 넣는 일 뿐이지 뭔갈 작업하는 것이 아니다. 코드 블럭을 큐에 넣어줄 뿐이다. async라는 것은 비동기라는 것을 기억해야한다. 동기화된 방식이 아니다. 이렇게 처리하라고 코드를 적어놓아도 곧바로 처리가 된다는 것은 아니다. 큐에 들어가 있다가 언젠가 미래에 처리를 한다는 의미이다. 큐가 준비가 되었을 때 말이다. 

- Other (concurrent) queues(메인큐가 아닌)
  대부분 메인 큐가 아닌 작업은 시스템에서 제공하는 병렬 큐들을 사용하는 것이다. 시스템이 제공하는 큐는 4개가 있다. 4개의 큐는 각자 맡고 있는 서비스(QOS: Quality Of Service)가 있다. QOS는 시스템이 얼마나 특정 서비스에 중점을 두느냐를 말한다. 우선순위라고 생각하면 된다. 

  ``` swift
  QOS_CLASS_USER_INTERACTIVE //quick and high priority
  QOS_CLASS_USER_INITIATED //high priority, might take time
  QOS_CLASS_UTILITY //long running
  QOS_CLASS_BACKGROUND //user not concerned with this (prefetching, etc.)
  let queue = dispatch_get_global_queue(<one of the above>, 0)
  //0은 "reserved for future"이다.
  
  //단, swift3와 내용이 다를 수 있다.
  ```

  어떤 서비스에 높은 우선순위를 가진 큐는 그 서비스에 높은 QOS가 있을 것이다. 그 서비스에 집중하는 것이다. 완전히 구분되어 있지는 않지만 일반적으로 그렇다. 
  이 큐를 가져오려면 

  ```swift
  DispatchQueue.global().async{}
  ```

  위 코드를 호출해서 이 큐를 넣으면 된다.

  1. QOS_CLASS_USER_INTERACTIVE(사용자 상호작용)
      사용자와 상호작용 할 수 있는 큐를 달라고 할 수 있다. 사용자가 막 무엇인가 요청할 때 처리하는데 시간이 좀 걸려서 메인 큐에 두고 싶지는 않은 것이다. 그렇지만 가능한 빨리 이걸 처리하고 싶을 수 있다. 왜냐하면 사용자는 지금 앱을 통해 우리와 상호작용하고 있기 때문이다. 병렬 큐 중에서는 매우 높은 우선순위이지만 여전히 메인 큐보다는 낮은 순위이다. 예를 들면, 사용자가 손가락으로 드래그를 할 때 한편에선 뭔가를 계산해야 할 것이다. 짧은 시간동안 매우 집중적으로 처리되어야 하는 이미지를 실시간에 가깝도록 말이다. 그래서 쓰레드에서 벗어나 있으면 사용자가 드래그를 계속 하는 동안에는 결과를 볼 수 없을 것이다. 그러다가 결과가 계산되면 사용자도 그 결과를 확인할 수 있을 것이다. 그래서 처리 결과는 손가락으로 드래그하는 것보다 시간이 그만큼 걸리기 때문에 조금씩 느리게 나타날 것이다. 하지만 적어도 손가락이 움직이는 동안에 메인 큐는 손가락을 따라 계속 반응하고 있는 것이다. 
  2. QOS_CLASS_USER_INITIATED(사용자 초기화)
     사용자 초기화는 사용자가 어떤 처리를 요청했지만 상호작용이 필요한 처리 도중은 아니라 시간이 조금 걸릴지도 모르지만 곧바로 다시 돌아와야 할 때이다. 사용자가 지금 막 요청했기 때문이다. USER_INTERACTIVE보다는 우선 순위가 낮다. 
  3. QOS_CLASS_UTILITY
     이는 뒤에서 오랫동안 작동하는 것이다. 데이터를 가져오거나 데이터 베이스를 비운다던가 하는 경우에 말이다. 보통 사용자가 요청하지는 않았지만 프로그램을 위해 처리되어야 할 것들을 말한다. 
  4. QOS_CLASS_BACKGROUND
     이는 가장 낮은 순위로 오늘 해도 되고 내일 해도 되는 일들이다. 지금 당장 처리하지 않아도 상관 없는 것들이다. 아무도 다른 서비스를 원하지 않을 때 작동한다. 

  위 4개의 큐 중 하나를 가져올 수 있다. DispatchQueue.global().async{}에 원하는 특정 큐를 넣어주면 된다. 그리고 컴마 뒤에 '0'이라는 추가 인자가 있는데 언젠가를 위해 남겨둔다는 의미에서 저기에는 항상 0을 넣으면 된다. 

- 직접 제작하는 직렬 큐

  ```swift
  let serialQueue = DispatchQueue(label: "queuename")
  ```

  위를 호출하여 원하는 큐 이름을 넣어주고 (보통 디버그 창에서 볼 수 있는 이름을 짓는다.) 그 다음에 

  ```swift
  serialQueue.sync{}
  ```

  를 넣어서 직렬 큐를 만들고 싶다고 말을 하는 것이다. 이 큐는 꽤 높은 우선순위를 가지게 될 것이다. 이것이 필요한 때는 언제일까? 예를 들어, 큰 테이블(연락처와 같은 리스트)이 있다고 해보자. 다운로드해 올 수천장의 이미지가 들어갈 테이블 말이다. 작은 이미지들을 테이블에 넣어주려는 것이다. 이런 작업을 USER_INITIATED 같은 병렬 큐 중에 하나에서 처리할 수도 있겠지만 그러면 여러 쓰레드로 갈라질 것이다. 병렬적으로 가능한 많이 다운로드 하기 위해서 말이다. 이를 직렬로 하면 하나씩 처리를 할 것이다. 네트워크 접속 통로를 하나로 좁히는 방식이다. 

  더 많은 내용은 GCD(Grand Central Dispatch)에 있다.  

* 객체 지향으로 하는 방법
  NSOperationQueue와 NSOperation(여기서 NS접두어는 코코아에서 NextSTEP의 약자로 이름 충돌 사태를 막기위한 것) 클래스를 이용하는 것이다. 이를 객체지향으로 하는 이유는 좀더 추가적인 기능이 있는데, GCD로부터 감싸는 기능이 있다. 예를 들어, 처리해야할 두 가지 작업이 있는데, 병률 큐에 넣긴 하지만, 어떤 하나는 다른 하나가 끝나는 것에 영향을 받는다면  첫번째 작업이 끝날 때까지는 다른 작업을 보내주지 않는 것이다. 여러 작업들이 서로 의존하고 있는 경우에 객체지향적인 방법이 필요하다. 공식 문서를 참고하자.
* iOS API 멀티쓰레드화
  Dispatch에 더해서 iOS의 API관점에서 멀티 쓰레팅을 이해할 필요가 있다. 왜냐하면 iOS 전반에는 쓰레드를 사용해서 비동기적으로 처리하는 메소드들 수많은 메소드가 있기 때문이다. API에서 이런 메소드를 확인하는 방법은 이 메소드들의 인자 중 하나인 클로져이다. 클로저는 다른 쓰레드에서 처리되며 메인 큐가 아닌 다른 큐에서 비동기적으로 일어난다. 

